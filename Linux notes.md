# Linux命令

## 1、shell命令

```c
1、目录信息查看命令ls 

2、目录切换命令cd 

3、当前路径显示命令pwd

4、系统信息查看命令uname

5、清理屏幕命令clear

6、显示文件内容命令cat

7、切换用户身份命令sudo

8、文件拷贝命令cp

9、切换用户命令su

10、移动文件命令mv

11、创建文件夹命令mkdir

12、创建文件命令touch

13、删除命令rm

14、目录删除命令rmdir

15、显示网络配置信息命令ifconfig

16、重启命令reboot

17、关机命令poweroff

18、系统帮助命令man

19、数据同步写入磁盘命令sync

20、查找文件命令find

21、查找内容命令grep

22、文件夹大小查看命令du

23、磁盘空间检查命令df

24、使用gedit打开某个文件命令gedit

25、当前的系统进程查看命令ps 

26、进程实时运行状态查看命令top

27、文件类型查看命令file
```

## 2、压缩、解压缩

### 2.1  gzip压缩工具

1. gzip工具负责压缩和解压缩.gz格式的压缩包。

   ```
   gzip xxx				//压缩
   
   gzip -d xxx.gz			//解压缩
   ```

2. gzip对文件夹进行压缩

   ```
   gzip -r xxx				//对文件夹进行压缩
   
   gzip -rd xxx.gz			//对文件夹进行解压缩
   ```

- gzip虽然可以对文件夹进行压缩，但是并不能提供打包的服务，只是对文件夹中的所有文件进行了单独的压缩。

### 2.2  bzip2压缩工具

1. bzip2工具负责压缩和解压缩.bz2格式的压缩包。

   ```
   bzip2 -z xxx			//压缩
   
   bzip2 -d xxx.gz			//解压缩
   ```

### 2.3  tar打包工具

1. tar工具参数：

   ```
   -f，使用归档文件或 ARCHIVE 设备
   
   -c：创建新归档，创建压缩文件
   
   -x：从图档中解出文件，解压缩
   
   -j：使用bzip2压缩格式。
   
   -z：使用gzip压缩格式
   
   -v：打印出命令执行过程。
   ```

2. tar工具提供打包服务，就是将多个文件打包，比如:

   ```
   tar -vcf test.tar test	//将test打包成test.tar
   
   tar -vxf test.tar		//解包
   ```

   - **上面的tar命令只提供了打包和解包的功能，tar在提供打包和解包的同时使用gzip/bzip2进行压缩，实现类似windwos下winRAR软件的命令。**

3. 对.tar.bz2进行压缩和解压缩

   ```
   tar -vxjf xxx.tar.bz2	解压缩
   
   tar -vcjf xxx.tar.bz2 xxx 压缩
   ```

4. 对.tar.gz进行压缩和解压缩

   ```
   tar -vxzf	xxx.tar.gz		//解压缩
   
   tar -vczf xxx.tar.gz xxx 	//压缩
   ```

### 2.4  其他格式的压缩和解压缩

1. rar格式（需要先安装rar：`sudo apt-get install rar`）

   ```
   rar x xxx.rar		//解压缩
   
   rar a xxx.rar xxx	//压缩
   ```

2. zip格式

   ```
   unzip -v xxx.zip	//解压缩
   
   zip -rv xxx.zip xxx	//压缩
   ```

## 3、用户、用户组

### 3.1 Linux用户

​	Linux是多用户操作系统，不同的用户拥有不同的权限。可以查看和操作不同的文件。 Ubuntu有三种用户：

​	①初次创建的用户。

​	②root用户

​	③普通用户。

​	初次创建的用户权限比普通用户多，但是没有root用户多，初次创建的用户可以创建普通用户。

​	Linux用户记录在`/etc/passwd`这个文件内。

​	Linux用户密码记录在`/etc/shadow`这个文件内。

​	每个用户都有一个ID，叫做UID。

### 3.2 Linux用户组

​	为了方便管理，将用户进行分组，每个用户组都有一个ID，叫做GID。这样就可以设置非本组人员不能访问某些文件。每个用户可以属于多个不同的组。

​	用户组信息存储在/etc/group文件中。

### 3.3 创建用户和用户组

1. 图形化界面创建

   安装`gnome-system-tools`这个工具：

   ```
   sudo apt-get install gnome-system-tools
   ```

2. 命令创建

   ```
   添加用户：adduser命令，adduser 用户名
   
   用户查询：finger命令，finger 用户名
   
   修改用户密码：passwd命令，passwd 用户名
   
   删除用户：deluser命令，deluser 用户名
   ---------------------------------------
   添加用户组：addgroup命令，addgroup 用户组名
   
   显示组内用户名：groups命令，groups 用户组名
   
   删除用户组：delgroup命令，delgroup用户组名
   ```


## 4、Linux文件权限

### 4.1 文件权限介绍

- 使用`ls -l`命令查看当前目录所有文件的权限

- `-rw-rw-r--`就是文件权限，r(读)，w(写)，x(执行)为一组，三组分别对应拥有者权限、拥有者所在组权限、其他用户权限。

- 

### 4.2 文件权限修改

- 用二进制表示文件权限，即r=4，w=2，x=1，配合参数a(所有用户),u(归属用户),g(归属组),o(其他用户),=(赋予权限),+(添加权限),-(去除权限)，因此有两种方法修改权限。

- chmod [参数] [文件名/目录名]

  ```
  -c 效果类似“-v”参数，但仅回显更改的部分。
  -f 不显示错误信息。
  -R 递归处理，指定目录下的所有文件及其子文件目录一起处理。
  -v 显示指令的执行过程。
  ```

- 例  `chmod u-x hello		`    为归属用户去除可执行权限

​	    `chmod 777 hello`    将所有用户的权限改为可读可写可执行

### 4.3 文件归属者修改命令

- chown [参数] [用户名.<组名>] [文件名/目录]

  ```
  -c 效果同-v 类似，但仅显示更改的部分。
  -f 不显示错误信息。
  -h 只对符号连接的文件做修改，不改动其它任何相关的文件。
  -R 递归处理，将指定的目录下的所有文件和子目录一起处理。
  -v 显示处理过程。
  ```

​	例  `sudo chown root.root hello`   将`hello`改为`root`组的`root`用户所属

## 5、Linux连接文件

### 5.1 Linux连接文件

- Linux有两种连接文件：符号连接(软连接)和硬链接，符号链接类似Windows下的快捷方式。硬链接通过文件系统的inode连接来产生新文件名，而不是产生新文件。

- inode：记录文件属性，一个文件一个inode。inode相当于文件ID，查找文件的时候要先找到inode，然后才能读出文件的内容。
- 使用l`s -l` 或`ll`命令查看文件详细信息，即可得到连接属性

### 5.2 ln命令

- ln命令用于创建连接文件：	

  ```
  ln [参数] 源文件 目标文件
  ```

- 参数：-s 创建符号连接(软连接)，无此参数默认创建硬连接

​		  -f 强制创建连接文件，如果目标存在，那么先删除掉目标文件，然后再建立连接文件。

### 5.3 硬连接

- 硬链接是多个文件都指向同一个inode，硬链接知识点：

1. 具有相同inode的多个文件互为硬链接文件，创建硬链接相当于文件实体多了入口。

2. 对于硬链接文件，只有删除了源文件以及对应的所有硬连接文件，文件实体才会被删除。

3. 根据硬链接文件的特点，我们可以通过给文件创建硬连接的方式来防止文件误删除。

4. 不论修改源文件还是连接文件，另一个文件的数据都会被改变。

5. 硬连接不能跨文件系统。

6. 硬连接不能连接到目录。

   因为以上这些限制，硬链接其实不常用。

### 5.4 符号连接(软连接)

- 符号连接类似Windows下的快捷方式，符号链接也叫做软连接，软连接要用的多。符号连接相当于创建了一个独立的文件，这个文件会让数据读取指向它连接的哪个文件的文件名。软连接的特点：

1. 可以连接到目录。
2. 可以跨文件系统。
3. 删除源文件以后，软连接文件也就“打不开了”。
4. 符号连接文件通过->来指示具体的连接文件。
5. 符号连接时源文件要使用绝对路径，否则不在同一目录下时软连接出问题。5、Linux连接文件

## 6、vim编辑器

### 6.1 vim的三种工作模式：

1. 一般模式(指令模式)：默认模式，用vi打开一个软件以后自动进入到此模式。

2. 编辑模式：一般模式中无法编辑文件，要编辑文件就要进入编辑模式，按下“i、I、a、A、o、O、s、r”等就会进入到编辑模式。一般按下“a”进入编辑模式。按下ESC键可退出编辑模式。

3. 命令行模式(底行模式)：先进入到一般模式，然后输入：、/、？这三个中的任意一个就可以进入到命令行模式。

   <!--	/xxx，表示在文件中查找xxx	    -->	

### 6.2 常用命令

1. 命令行模式下：输入:wq来保存退出。:q退出，:q!不保存退出，:w保存。

2. 一般模式下：

   ```
   1、 dd	,删除光标所在行,ndd,删除光标所在行及其下n行。
   2、 u	,撤销，恢复上一步。
   3、 .	,重复前一个操作。
   4、 yy	,复制光标所在行
   5， nyy	,复制光标所在向下n行,比如10yy就是复制光标下10行。
   6， p和P ,p为复制到光标下一行，P复制到光标上一行。
   ```

### 6.3 常用设置

1. vim编辑器默认Tab键为8空格，使用`vi /etc/vim/vimrc`在配置文件最后加上 `set ts=4`即可
2. vim编辑器默认不显示行号，使用`vi /etc/vim/vimrc`在配置文件最后加上 `set nu`即可

## 7、 Makefile 介绍及使用

### 7.1 基本语法

- 在有主函数 `main` 以及实现输入的函数 `input` 、实现加法的函数 `calcu` 的情境下，需要使用命令：`gcc -o main main.o calcu.o input.o`  进行链接生成可执行文件 `main` ，此时若修改`input.c` 后想要重新编译需要编译所有文件，使用 `Makefile` 可以只编译修改过的文件，语法如下：

  ```
  main: main.o input.o calcu.o 
  	gcc  -o main main.o input.o calcu.o
  main.o: main.c
  	gcc-c main.c
  input.o: input.c
  	gcc -c input.c
  calcu.o: calcu.c
  	gcc-c calcu.c
  	
  clean:
  	rm *.o
  	rm main
  ```

  使用命令 `make` 会自动查找当前目录下的 `Makefile` 并按需编译生成 `main` 可执行文件，使用命令 `clean` 会执行 

  ```
  rm *.o
  rm main
  ```

### 7.2 常用技巧

- `Makefile` 语法中的变量只有字符串，调用时在变量前加上 `$` 即可，类似于宏替换，例：

  ```
  # Makefile 变量的使用
  objects = main.o input.o calcu.o 
  main: $(objects)
  	gcc -o main $(objects)
  ```

- 不同赋值符的用法

  1. 在使用" = "给变量赋值时，会使用最后一次定义的值，例：

     ```
      name = zzk
      curname = $(name) 
      name = zuozongkai
     
      print: 
      @echo curname: $(curname)     # 注: @echo 表示不回显这条命令
     ```

     最后打印的结果是 `zuozongkai`

  2. 在使用" := "给变量赋值时，不会使用最后一次定义的值，因此打印结果是 `zzk` 

  3. 在使用" ?= "给变量赋值时，若前方有赋值，则使用前值，若前方无赋值，则使用本值

  4. 在使用" +="给变量赋值时，语义同C语言，将右值追加到原有的字符串


- 模式规则 : "%.c" 可以匹配所有以.c结尾的文件，此处的 "%" 类似于通配符 "*" 

### 7.3 自动化变量

- | 自动化变量 | 描述                                       |
  | ---------- | ------------------------------------------ |
  | $@         | 匹配规则中的所有目标集合                   |
  | $%         | 匹配规则中的函数库目标集合                 |
  | $<         | 匹配符合模式的文件几个                     |
  | $?         | 所有比目标新的依赖目标集合，以空格分开     |
  | $^         | 所有依赖文件集合去重以后的集合，以空格分开 |
  | $+         | 所有依赖文件集合(不会去重)，以空格分开     |
  | $*         | 匹配%及其之前的部分                        |

  修改后：

  ```
  objects = main.o input.o calcu.o 
  main: $(objects) 
  	gcc -o main $(objects) 
  	
  %.o : %.c 
  	gcc -c $< 
  
  clean: 
  	rm *.o
  	rm main
  ```

- 伪目标：使用命令  `.PHONY:clean` 声明 `clean` 为伪目标后，无论目录下是否存在名为 `clean` 的文件，输入 ` make clean` 都会执行 `clean` 规则后的 `rm` 命令，用于防止将clean视为依赖文件而错误地执行命令

### 7.4 条件判断

- 关键字：`ifeq ` `ifneq` `ifdef` `ifndef` `else` `
